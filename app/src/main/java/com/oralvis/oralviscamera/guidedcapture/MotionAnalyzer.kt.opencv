package com.oralvis.oralviscamera.guidedcapture

import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import org.opencv.android.OpenCVLoader
import org.opencv.core.Core
import org.opencv.core.CvType
import org.opencv.core.Mat
import org.opencv.core.Size
import org.opencv.imgproc.Imgproc
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.math.sqrt

/**
 * MotionAnalyzer performs frame-difference motion analysis on camera preview frames.
 * 
 * FULL IMPLEMENTATION - Replace MotionAnalyzer.kt with this file after adding OpenCV module.
 * 
 * This class:
 * - Receives NV21 frames from the camera pipeline
 * - Samples frames at ~8-10 FPS (drops frames in between)
 * - Computes motion metrics using OpenCV frame difference
 * - Only processes during SCANNING_LOWER or SCANNING_UPPER states
 * - Emits MotionState with mu (mean motion) and sigma (std dev)
 * - Runs on a background thread (HandlerThread)
 *
 * Design:
 * - Uses frame difference (absdiff) for simplicity and speed
 * - Resizes frames to ≤160×120 for performance
 * - Reuses Mat objects to avoid allocation overhead
 * - Tracks recent motion values to compute mu and sigma
 */
class MotionAnalyzer {

    companion object {
        private const val TAG = "MotionAnalyzer"
        
        // Frame sampling: target 8-10 FPS
        private const val SAMPLE_INTERVAL_MS = 100L // 10 FPS
        
        // Motion analysis parameters
        private const val TARGET_WIDTH = 160
        private const val TARGET_HEIGHT = 120
        
        // History for mu/sigma computation
        private const val MOTION_HISTORY_SIZE = 10
    }

    var onMotionStateUpdated: ((MotionState) -> Unit)? = null

    private val isRunning = AtomicBoolean(false)
    private var workerThread: HandlerThread? = null
    private var workerHandler: Handler? = null
    
    // Frame sampling
    private var lastSampleTimeMs: Long = 0
    
    // OpenCV Mat objects (reused to avoid allocation)
    private var prevGrayMat: Mat? = null
    private var currGrayMat: Mat? = null
    private var diffMat: Mat? = null
    private var resizedMat: Mat? = null
    
    // Motion history for mu/sigma computation
    private val motionHistory = mutableListOf<Double>()
    
    // Current scanning state (set externally)
    @Volatile
    var scanningState: ScanningState = ScanningState.READY_TO_SCAN_LOWER
        set(value) {
            field = value
            // Clear previous frame when state changes (not scanning)
            if (value != ScanningState.SCANNING_LOWER && value != ScanningState.SCANNING_UPPER) {
                clearPreviousFrame()
            }
        }

    init {
        // Initialize OpenCV
        if (!OpenCVLoader.initDebug()) {
            Log.e(TAG, "OpenCV initialization failed")
        } else {
            Log.d(TAG, "OpenCV initialized successfully")
        }
    }

    fun start() {
        if (isRunning.getAndSet(true)) {
            Log.w(TAG, "MotionAnalyzer already started")
            return
        }
        
        workerThread = HandlerThread("MotionAnalyzer").apply {
            start()
            workerHandler = Handler(looper)
        }
        
        Log.d(TAG, "MotionAnalyzer started")
    }

    fun stop() {
        if (!isRunning.getAndSet(false)) {
            return
        }
        
        workerHandler?.removeCallbacksAndMessages(null)
        workerThread?.quitSafely()
        workerThread = null
        workerHandler = null
        
        // Clean up OpenCV Mats
        releaseMats()
        
        // Clear state
        motionHistory.clear()
        lastSampleTimeMs = 0
        
        Log.d(TAG, "MotionAnalyzer stopped")
    }

    /**
     * Process an NV21 frame from the camera.
     * This method should be called from the camera preview callback.
     * Frame sampling (8-10 FPS) happens here.
     */
    fun onFrame(data: ByteArray, width: Int, height: Int) {
        if (!isRunning.get()) return
        
        // Gate by scanning state
        if (scanningState != ScanningState.SCANNING_LOWER && 
            scanningState != ScanningState.SCANNING_UPPER) {
            return
        }
        
        // Frame sampling: only process every SAMPLE_INTERVAL_MS
        val nowMs = System.currentTimeMillis()
        if (nowMs - lastSampleTimeMs < SAMPLE_INTERVAL_MS) {
            return
        }
        lastSampleTimeMs = nowMs
        
        // Process on background thread
        workerHandler?.post {
            processFrame(data, width, height)
        }
    }

    /**
     * Process a single frame using OpenCV frame difference.
     * Runs on background thread.
     */
    private fun processFrame(data: ByteArray, width: Int, height: Int) {
        try {
            // NV21 format: first width*height bytes are Y (luma) channel
            // Extract Y channel directly for grayscale (more efficient than conversion)
            val ySize = width * height
            val yData = ByteArray(ySize)
            System.arraycopy(data, 0, yData, 0, ySize)
            
            // Create Mat from Y channel
            val grayMat = Mat(height, width, CvType.CV_8UC1)
            grayMat.put(0, 0, yData)
            
            // Resize to target size for performance
            val targetSize = Size(TARGET_WIDTH.toDouble(), TARGET_HEIGHT.toDouble())
            if (resizedMat == null) {
                resizedMat = Mat()
            }
            Imgproc.resize(grayMat, resizedMat!!, targetSize)
            grayMat.release()
            
            // Compute motion if we have a previous frame
            val motionLevel = if (prevGrayMat != null) {
                computeMotion(resizedMat!!)
            } else {
                // First frame: no motion
                0.0
            }
            
            // Update previous frame
            if (prevGrayMat == null) {
                prevGrayMat = Mat()
            }
            resizedMat!!.copyTo(prevGrayMat!!)
            
            // Update motion history and compute mu/sigma
            updateMotionHistory(motionLevel)
            val (mu, sigma) = computeMotionStats()
            
            // Determine warnings (thresholds match AutoCaptureController defaults)
            val speedWarning = mu >= 4.0
            val stabilityWarning = sigma >= 3.0
            
            // Emit MotionState
            val motionState = MotionState(
                mu = mu,
                sigma = sigma,
                speedWarning = speedWarning,
                stabilityWarning = stabilityWarning
            )
            
            Log.d(TAG, "motionLevel=$motionLevel, mu=$mu, sigma=$sigma, state=$scanningState")
            
            // Emit on main thread to avoid threading issues
            android.os.Handler(android.os.Looper.getMainLooper()).post {
                onMotionStateUpdated?.invoke(motionState)
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error processing frame", e)
        }
    }

    /**
     * Compute motion level using frame difference.
     */
    private fun computeMotion(currentGray: Mat): Double {
        if (diffMat == null) {
            diffMat = Mat()
        }
        
        // Compute absolute difference
        Core.absdiff(prevGrayMat!!, currentGray, diffMat!!)
        
        // Compute mean of difference
        val meanScalar = Core.mean(diffMat!!)
        return meanScalar.`val`[0]
    }

    /**
     * Update motion history and maintain fixed size.
     */
    private fun updateMotionHistory(motionLevel: Double) {
        motionHistory.add(motionLevel)
        if (motionHistory.size > MOTION_HISTORY_SIZE) {
            motionHistory.removeAt(0)
        }
    }

    /**
     * Compute mu (mean) and sigma (std dev) from motion history.
     */
    private fun computeMotionStats(): Pair<Double, Double> {
        if (motionHistory.isEmpty()) {
            return 0.0 to 0.0
        }
        
        val mean = motionHistory.average()
        
        // Compute standard deviation
        val variance = motionHistory.map { (it - mean) * (it - mean) }.average()
        val sigma = sqrt(variance)
        
        return mean to sigma
    }

    /**
     * Clear previous frame when not scanning.
     */
    private fun clearPreviousFrame() {
        workerHandler?.post {
            prevGrayMat?.release()
            prevGrayMat = null
            motionHistory.clear()
            Log.d(TAG, "Cleared previous frame (not scanning)")
        }
    }

    /**
     * Release all OpenCV Mat objects.
     */
    private fun releaseMats() {
        prevGrayMat?.release()
        currGrayMat?.release()
        diffMat?.release()
        resizedMat?.release()
        
        prevGrayMat = null
        currGrayMat = null
        diffMat = null
        resizedMat = null
    }
}
